{"version":3,"sources":["src/map.js","node_modules/easystarjs/src/instance.js","node_modules/easystarjs/src/node.js","node_modules/heap/lib/heap.js","node_modules/heap/index.js","node_modules/easystarjs/src/easystar.js","src/Cell.js","src/Agent.js","src/Agents/SmartAgent.js","src/Agents/RandomAgent.js","src/Agents/ClosestAgent.js","src/World.js","src/index.js"],"names":["map","mapDirection","Cell","MAX_PARKED_BIKES","world","type","x","y","allowed_direction","agents","bikes","agent","filter","length","push","a","ctx","squareSize","drawDirection","drawCoords","drawCount","canvas_x","canvas_y","color","getCellColor","fillStyle","fillRect","font","globalAlpha","arrow","fillText","String","padStart","bikeAgents","pedestrianAgents","forEach","i","path","cell","drawBike","drawPedestrian","includes","orientation","Agent","strategy","spawn","parked_cell","move_to","exitRate","calculatingPath","stage","ticks","ticks_to_parked","ticks_to_goal","bikePathfinder","pedestrianPathfinder","addTimeToPark","addTimeToGoal","location","canPark","addBike","addLotCapacity","hasParked","removeBike","removeLotCapacity","callback","pathfinder","getPathfinder","findPath","console","log","calculate","nextCell","checkAddAgent","moveAgent","shift","getCellAtCoordinates","makeMove","buildingCell","getRandomCellOfType","changeMoveTo","executePathSequence","hasReachedGoal","Math","random","unpark","lotChoice","removeAgent","warn","SmartAgent","lots","lotPreference","changePreference","searchPath","searchTime","searchFail","min","max","floor","coordinates","Array","randomValueInRange","goal_cell","state","pop","maxPref","index","indexOf","round","startAct","checkPreference","randomLotCoordinates","decreasePreference","choice","getLotCapacity","lotSearch","park","increasePreference","finishedParkingStages","RandomAgent","parkingCell","ClosestAgent","coords","Q","grid","label","BFS","V","dirs","next","undefined","World","getDirectionArray","direction","EasyStar","BOTTOM","TOP","LEFT","RIGHT","worldmap","selectedStrategies","agentsActive","agentsInactive","northCapacity","eastCapacity","midCapacity","westCapacity","tickCount","rows","split","row","directionRows","types","S","E","X","b","w","p","_","o","js","entries","directionRow","rowData","c","setDirectionalCondition","setGrid","setAcceptableTiles","setTileCost","cells","flat","stragegy","oldAgent","find","addAgent","respawn","newAgent","getAgentClass","sort","act","experimentTicks","automatedLoopLength","maxSpawnRateLimit","STRATEGIES","currentTick","csvRowsPark","csvRowsGoal","timeToParkData","timeToGoalData","trendData","clearTrendData","experimentMode","spawnRateType","minSpawnRate","maxSpawnRate","tickDelay","oldTickDelay","spawnspeed","paused","reset","strategyName","toLowerCase","replace","s","d","toUpperCase","getSpawnRate","currentBin","pow","sin","PI","document","getElementById","onclick","spawnRates","updateSpawnRates","drawSpawnRate","innerHTML","canvas","getContext","width","height","barWidth","barHeight","clearRect","lineWidth","strokeStyle","beginPath","moveTo","lineTo","stroke","currentIndex","arc","fill","addEventListener","e","target","value","event","disabled","strategyCheckboxes","container","createElement","classList","add","checkbox","id","checked","htmlFor","appendChild","createTextNode","data","openResultsModal","DrawChart","DrawTrend","style","display","closeResultsModal","google","visualization","arrayToDataTable","options","bar","gap","interpolateNulls","chartArea","left","top","bottom","histogram","bucketSize","maxNumBuckets","minValue","maxValue","lastBucketPercentile","Histogram","draw","dataRows","strategies","Object","keys","strategyData","averagedData","slice","average","reduce","maxDataPoints","dataCombined","dataColumns","trendlines","visibleInLegend","trendOptions","explorer","LineChart","charts","load","packages","setOnLoadCallback","gameTick","rate","spawnAgent","tick","setTimeout","gridWidth","gridHeight","canvasWidth","canvasHeight","drawCanvas","requestAnimationFrame","downloadCSV","csv","filename","csvFile","downloadLink","Blob","download","join","href","window","URL","createObjectURL","body","click"],"mappings":"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","file":"src.2e049ef9.js","sourceRoot":"..","sourcesContent":["const map = `\n____________________________________\nbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb__\nbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb__\n_bbw______________aa____________bb__\n_bbw______________aappppppppppa_bb__\n_bbw______________aappppppppppaaaaaS\n_bbw______________aappppppppppaaaaaE\n_bbw______________aa________________\n_bbw__ooooooooooooaa________________\n_bbw__ooooooooooooaa________________\n_bbw__ooooooooooooaa________________\n_bbw__ooooooooooooaa________________\n_bbw__ooooooooooooaa________________\n_bbw__ooooooooooooaa________________\n_bbw__ooooooooooooaa________________\n_bbw__ooooooooooooaa________________\n_bbwwwooooooooooooaa________________\n_bbappoooopppppppoaa________________\n_bbappoooopppppppoaa________________\n_bbappooooooooooaaaa___pppppp_______\n_bbwwwooooooooooooaa___pppppp_______\n_bbwwwoooooooooooXaaaaaaaaaaaaaaaaaS\n_bbwwwooooooooooooaaaaaaaaaaaaaaaaaE\n_bbwwwooooooooooooaa___pppppp_______\n_bbwwwooooooooooooaa________________\n_bbaaa____________aa________________\n_bbaaaaaaaaaaaaaaaaaa_______________\n_bbaaaaaaaaaaaaaaaaaa_______________\n_bbw_____________aaaaa______________\n_bbw______________aaaaa_____________\n_bbw______________aaaaa_____________\n_bbw________________________________\n_bbw________________________________\n_bbw________________________________\n_bbw________________________________\n_ESw________________________________\n`;\n\nexport const mapDirection = `\n____________________________________\nwawwwwwwwwwwwwwwwwaawwwwwwwwwwwwwa__\neaaeeeeeeeeeeeeeeeaaeeeeeeeeeeeean__\n_sna______________sn____________sn__\n_sna______________aahhhhhhhhhha_sn__\n_sna______________aahhhhhhhhhhawaawa\n_sna______________aahhhhhhhhhhaeaaea\n_sna______________sn________________\n_sna______________sn________________\n_sna______________sn________________\n_sna______________sn________________\n_sna______________sn________________\n_sna______________sn________________\n_sna______________sn________________\n_sna______________sn________________\n_sna______________sn________________\n_aaaaa____________sn________________\n_aaahh____hhhhhha_sn________________\n_aaahh____hhhhhha_sn________________\n_aaahh__________aaaa___vvvvvv_______\n_snaaa____________sn___vvvvvv_______\n_snaaa___________aaawwwaaaaaawwwwwwa\n_snaaa____________aaeeeaaaaaaeeeeeea\n_snaaa____________sn___vvvvvv_______\n_snaaa____________sn________________\n_snaaa____________sn________________\n_aaawwwwwwwwwwwwwwana_______________\n_aaaeeeeeeeeeeeeeeeaa_______________\n_sna_____________aaaaa______________\n_sna______________aaaaa_____________\n_sna______________aaaaa_____________\n_sna________________________________\n_sna________________________________\n_sna________________________________\n_sna________________________________\n_aaa________________________________\n`;\n\nexport default map;\n","/**\n * Represents a single instance of EasyStar.\n * A path that is in the queue to eventually be found.\n */\nmodule.exports = function() {\n    this.pointsToAvoid = {};\n    this.startX;\n    this.callback;\n    this.startY;\n    this.endX;\n    this.endY;\n    this.nodeHash = {};\n    this.openList;\n};","/**\n* A simple Node that represents a single tile on the grid.\n* @param {Object} parent The parent node.\n* @param {Number} x The x position on the grid.\n* @param {Number} y The y position on the grid.\n* @param {Number} costSoFar How far this node is in moves*cost from the start.\n* @param {Number} simpleDistanceToTarget Manhatten distance to the end point.\n**/\nmodule.exports = function(parent, x, y, costSoFar, simpleDistanceToTarget) {\n    this.parent = parent;\n    this.x = x;\n    this.y = y;\n    this.costSoFar = costSoFar;\n    this.simpleDistanceToTarget = simpleDistanceToTarget;\n\n    /**\n    * @return {Number} Best guess distance of a cost using this node.\n    **/\n    this.bestGuessDistance = function() {\n        return this.costSoFar + this.simpleDistanceToTarget;\n    }\n};","// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n","module.exports = require('./lib/heap');\n","/**\n*   EasyStar.js\n*   github.com/prettymuchbryce/EasyStarJS\n*   Licensed under the MIT license.\n*\n*   Implementation By Bryce Neal (@prettymuchbryce)\n**/\n\nvar EasyStar = {}\nvar Instance = require('./instance');\nvar Node = require('./node');\nvar Heap = require('heap');\n\nconst CLOSED_LIST = 0;\nconst OPEN_LIST = 1;\n\nmodule.exports = EasyStar;\n\nvar nextInstanceId = 1;\n\nEasyStar.js = function() {\n    var STRAIGHT_COST = 1.0;\n    var DIAGONAL_COST = 1.4;\n    var syncEnabled = false;\n    var pointsToAvoid = {};\n    var collisionGrid;\n    var costMap = {};\n    var pointsToCost = {};\n    var directionalConditions = {};\n    var allowCornerCutting = true;\n    var iterationsSoFar;\n    var instances = {};\n    var instanceQueue = [];\n    var iterationsPerCalculation = Number.MAX_VALUE;\n    var acceptableTiles;\n    var diagonalsEnabled = false;\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array|Number} tiles An array of numbers that represent\n    * which tiles in your grid should be considered\n    * acceptable, or \"walkable\".\n    **/\n    this.setAcceptableTiles = function(tiles) {\n        if (tiles instanceof Array) {\n            // Array\n            acceptableTiles = tiles;\n        } else if (!isNaN(parseFloat(tiles)) && isFinite(tiles)) {\n            // Number\n            acceptableTiles = [tiles];\n        }\n    };\n\n    /**\n    * Enables sync mode for this EasyStar instance..\n    * if you're into that sort of thing.\n    **/\n    this.enableSync = function() {\n        syncEnabled = true;\n    };\n\n    /**\n    * Disables sync mode for this EasyStar instance.\n    **/\n    this.disableSync = function() {\n        syncEnabled = false;\n    };\n\n    /**\n     * Enable diagonal pathfinding.\n     */\n    this.enableDiagonals = function() {\n        diagonalsEnabled = true;\n    }\n\n    /**\n     * Disable diagonal pathfinding.\n     */\n    this.disableDiagonals = function() {\n        diagonalsEnabled = false;\n    }\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array} grid The collision grid that this EasyStar instance will read from.\n    * This should be a 2D Array of Numbers.\n    **/\n    this.setGrid = function(grid) {\n        collisionGrid = grid;\n\n        //Setup cost map\n        for (var y = 0; y < collisionGrid.length; y++) {\n            for (var x = 0; x < collisionGrid[0].length; x++) {\n                if (!costMap[collisionGrid[y][x]]) {\n                    costMap[collisionGrid[y][x]] = 1\n                }\n            }\n        }\n    };\n\n    /**\n    * Sets the tile cost for a particular tile type.\n    *\n    * @param {Number} The tile type to set the cost for.\n    * @param {Number} The multiplicative cost associated with the given tile.\n    **/\n    this.setTileCost = function(tileType, cost) {\n        costMap[tileType] = cost;\n    };\n\n    /**\n    * Sets the an additional cost for a particular point.\n    * Overrides the cost from setTileCost.\n    *\n    * @param {Number} x The x value of the point to cost.\n    * @param {Number} y The y value of the point to cost.\n    * @param {Number} The multiplicative cost associated with the given point.\n    **/\n    this.setAdditionalPointCost = function(x, y, cost) {\n        if (pointsToCost[y] === undefined) {\n            pointsToCost[y] = {};\n        }\n        pointsToCost[y][x] = cost;\n    };\n\n    /**\n    * Remove the additional cost for a particular point.\n    *\n    * @param {Number} x The x value of the point to stop costing.\n    * @param {Number} y The y value of the point to stop costing.\n    **/\n    this.removeAdditionalPointCost = function(x, y) {\n        if (pointsToCost[y] !== undefined) {\n            delete pointsToCost[y][x];\n        }\n    }\n\n    /**\n    * Remove all additional point costs.\n    **/\n    this.removeAllAdditionalPointCosts = function() {\n        pointsToCost = {};\n    }\n\n    /**\n    * Sets a directional condition on a tile\n    *\n    * @param {Number} x The x value of the point.\n    * @param {Number} y The y value of the point.\n    * @param {Array.<String>} allowedDirections A list of all the allowed directions that can access\n    * the tile.\n    **/\n    this.setDirectionalCondition = function(x, y, allowedDirections) {\n        if (directionalConditions[y] === undefined) {\n            directionalConditions[y] = {};\n        }\n        directionalConditions[y][x] = allowedDirections;\n    };\n\n    /**\n    * Remove all directional conditions\n    **/\n    this.removeAllDirectionalConditions = function() {\n        directionalConditions = {};\n    };\n\n    /**\n    * Sets the number of search iterations per calculation.\n    * A lower number provides a slower result, but more practical if you\n    * have a large tile-map and don't want to block your thread while\n    * finding a path.\n    *\n    * @param {Number} iterations The number of searches to prefrom per calculate() call.\n    **/\n    this.setIterationsPerCalculation = function(iterations) {\n        iterationsPerCalculation = iterations;\n    };\n\n    /**\n    * Avoid a particular point on the grid,\n    * regardless of whether or not it is an acceptable tile.\n    *\n    * @param {Number} x The x value of the point to avoid.\n    * @param {Number} y The y value of the point to avoid.\n    **/\n    this.avoidAdditionalPoint = function(x, y) {\n        if (pointsToAvoid[y] === undefined) {\n            pointsToAvoid[y] = {};\n        }\n        pointsToAvoid[y][x] = 1;\n    };\n\n    /**\n    * Stop avoiding a particular point on the grid.\n    *\n    * @param {Number} x The x value of the point to stop avoiding.\n    * @param {Number} y The y value of the point to stop avoiding.\n    **/\n    this.stopAvoidingAdditionalPoint = function(x, y) {\n        if (pointsToAvoid[y] !== undefined) {\n            delete pointsToAvoid[y][x];\n        }\n    };\n\n    /**\n    * Enables corner cutting in diagonal movement.\n    **/\n    this.enableCornerCutting = function() {\n        allowCornerCutting = true;\n    };\n\n    /**\n    * Disables corner cutting in diagonal movement.\n    **/\n    this.disableCornerCutting = function() {\n        allowCornerCutting = false;\n    };\n\n    /**\n    * Stop avoiding all additional points on the grid.\n    **/\n    this.stopAvoidingAllAdditionalPoints = function() {\n        pointsToAvoid = {};\n    };\n\n    /**\n    * Find a path.\n    *\n    * @param {Number} startX The X position of the starting point.\n    * @param {Number} startY The Y position of the starting point.\n    * @param {Number} endX The X position of the ending point.\n    * @param {Number} endY The Y position of the ending point.\n    * @param {Function} callback A function that is called when your path\n    * is found, or no path is found.\n    * @return {Number} A numeric, non-zero value which identifies the created instance. This value can be passed to cancelPath to cancel the path calculation.\n    *\n    **/\n    this.findPath = function(startX, startY, endX, endY, callback) {\n        // Wraps the callback for sync vs async logic\n        var callbackWrapper = function(result) {\n            if (syncEnabled) {\n                callback(result);\n            } else {\n                setTimeout(function() {\n                    callback(result);\n                });\n            }\n        }\n\n        // No acceptable tiles were set\n        if (acceptableTiles === undefined) {\n            throw new Error(\"You can't set a path without first calling setAcceptableTiles() on EasyStar.\");\n        }\n        // No grid was set\n        if (collisionGrid === undefined) {\n            throw new Error(\"You can't set a path without first calling setGrid() on EasyStar.\");\n        }\n\n        // Start or endpoint outside of scope.\n        if (startX < 0 || startY < 0 || endX < 0 || endY < 0 ||\n        startX > collisionGrid[0].length-1 || startY > collisionGrid.length-1 ||\n        endX > collisionGrid[0].length-1 || endY > collisionGrid.length-1) {\n            throw new Error(\"Your start or end point is outside the scope of your grid.\");\n        }\n\n        // Start and end are the same tile.\n        if (startX===endX && startY===endY) {\n            callbackWrapper([]);\n            return;\n        }\n\n        // End point is not an acceptable tile.\n        var endTile = collisionGrid[endY][endX];\n        var isAcceptable = false;\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (endTile === acceptableTiles[i]) {\n                isAcceptable = true;\n                break;\n            }\n        }\n\n        if (isAcceptable === false) {\n            callbackWrapper(null);\n            return;\n        }\n\n        // Create the instance\n        var instance = new Instance();\n        instance.openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.bestGuessDistance() - nodeB.bestGuessDistance();\n        });\n        instance.isDoneCalculating = false;\n        instance.nodeHash = {};\n        instance.startX = startX;\n        instance.startY = startY;\n        instance.endX = endX;\n        instance.endY = endY;\n        instance.callback = callbackWrapper;\n\n        instance.openList.push(coordinateToNode(instance, instance.startX,\n            instance.startY, null, STRAIGHT_COST));\n\n        var instanceId = nextInstanceId ++;\n        instances[instanceId] = instance;\n        instanceQueue.push(instanceId);\n        return instanceId;\n    };\n\n    /**\n     * Cancel a path calculation.\n     *\n     * @param {Number} instanceId The instance ID of the path being calculated\n     * @return {Boolean} True if an instance was found and cancelled.\n     *\n     **/\n    this.cancelPath = function(instanceId) {\n        if (instanceId in instances) {\n            delete instances[instanceId];\n            // No need to remove it from instanceQueue\n            return true;\n        }\n        return false;\n    };\n\n    /**\n    * This method steps through the A* Algorithm in an attempt to\n    * find your path(s). It will search 4-8 tiles (depending on diagonals) for every calculation.\n    * You can change the number of calculations done in a call by using\n    * easystar.setIteratonsPerCalculation().\n    **/\n    this.calculate = function() {\n        if (instanceQueue.length === 0 || collisionGrid === undefined || acceptableTiles === undefined) {\n            return;\n        }\n        for (iterationsSoFar = 0; iterationsSoFar < iterationsPerCalculation; iterationsSoFar++) {\n            if (instanceQueue.length === 0) {\n                return;\n            }\n\n            if (syncEnabled) {\n                // If this is a sync instance, we want to make sure that it calculates synchronously.\n                iterationsSoFar = 0;\n            }\n\n            var instanceId = instanceQueue[0];\n            var instance = instances[instanceId];\n            if (typeof instance == 'undefined') {\n                // This instance was cancelled\n                instanceQueue.shift();\n                continue;\n            }\n\n            // Couldn't find a path.\n            if (instance.openList.size() === 0) {\n                instance.callback(null);\n                delete instances[instanceId];\n                instanceQueue.shift();\n                continue;\n            }\n\n            var searchNode = instance.openList.pop();\n\n            // Handles the case where we have found the destination\n            if (instance.endX === searchNode.x && instance.endY === searchNode.y) {\n                var path = [];\n                path.push({x: searchNode.x, y: searchNode.y});\n                var parent = searchNode.parent;\n                while (parent!=null) {\n                    path.push({x: parent.x, y:parent.y});\n                    parent = parent.parent;\n                }\n                path.reverse();\n                var ip = path;\n                instance.callback(ip);\n                delete instances[instanceId];\n                instanceQueue.shift();\n                continue;\n            }\n\n            searchNode.list = CLOSED_LIST;\n\n            if (searchNode.y > 0) {\n                checkAdjacentNode(instance, searchNode,\n                    0, -1, STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y-1));\n            }\n            if (searchNode.x < collisionGrid[0].length-1) {\n                checkAdjacentNode(instance, searchNode,\n                    1, 0, STRAIGHT_COST * getTileCost(searchNode.x+1, searchNode.y));\n            }\n            if (searchNode.y < collisionGrid.length-1) {\n                checkAdjacentNode(instance, searchNode,\n                    0, 1, STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y+1));\n            }\n            if (searchNode.x > 0) {\n                checkAdjacentNode(instance, searchNode,\n                    -1, 0, STRAIGHT_COST * getTileCost(searchNode.x-1, searchNode.y));\n            }\n            if (diagonalsEnabled) {\n                if (searchNode.x > 0 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1, searchNode) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y, searchNode))) {\n\n                        checkAdjacentNode(instance, searchNode,\n                            -1, -1, DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y-1));\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1, searchNode) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y, searchNode))) {\n\n                        checkAdjacentNode(instance, searchNode,\n                            1, 1, DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y+1));\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1, searchNode) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y, searchNode))) {\n\n                        checkAdjacentNode(instance, searchNode,\n                            1, -1, DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y-1));\n                    }\n                }\n                if (searchNode.x > 0 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1, searchNode) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y, searchNode))) {\n\n                        checkAdjacentNode(instance, searchNode,\n                            -1, 1, DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y+1));\n                    }\n                }\n            }\n\n        }\n    };\n\n    // Private methods follow\n    var checkAdjacentNode = function(instance, searchNode, x, y, cost) {\n        var adjacentCoordinateX = searchNode.x+x;\n        var adjacentCoordinateY = searchNode.y+y;\n\n        if ((pointsToAvoid[adjacentCoordinateY] === undefined ||\n             pointsToAvoid[adjacentCoordinateY][adjacentCoordinateX] === undefined) &&\n            isTileWalkable(collisionGrid, acceptableTiles, adjacentCoordinateX, adjacentCoordinateY, searchNode)) {\n            var node = coordinateToNode(instance, adjacentCoordinateX,\n                adjacentCoordinateY, searchNode, cost);\n\n            if (node.list === undefined) {\n                node.list = OPEN_LIST;\n                instance.openList.push(node);\n            } else if (searchNode.costSoFar + cost < node.costSoFar) {\n                node.costSoFar = searchNode.costSoFar + cost;\n                node.parent = searchNode;\n                instance.openList.updateItem(node);\n            }\n        }\n    };\n\n    // Helpers\n    var isTileWalkable = function(collisionGrid, acceptableTiles, x, y, sourceNode) {\n        var directionalCondition = directionalConditions[y] && directionalConditions[y][x];\n        if (directionalCondition) {\n            var direction = calculateDirection(sourceNode.x - x, sourceNode.y - y)\n            var directionIncluded = function () {\n                for (var i = 0; i < directionalCondition.length; i++) {\n                    if (directionalCondition[i] === direction) return true\n                }\n                return false\n            }\n            if (!directionIncluded()) return false\n        }\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (collisionGrid[y][x] === acceptableTiles[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * -1, -1 | 0, -1  | 1, -1\n     * -1,  0 | SOURCE | 1,  0\n     * -1,  1 | 0,  1  | 1,  1\n     */\n    var calculateDirection = function (diffX, diffY) {\n        if (diffX === 0 && diffY === -1) return EasyStar.TOP\n        else if (diffX === 1 && diffY === -1) return EasyStar.TOP_RIGHT\n        else if (diffX === 1 && diffY === 0) return EasyStar.RIGHT\n        else if (diffX === 1 && diffY === 1) return EasyStar.BOTTOM_RIGHT\n        else if (diffX === 0 && diffY === 1) return EasyStar.BOTTOM\n        else if (diffX === -1 && diffY === 1) return EasyStar.BOTTOM_LEFT\n        else if (diffX === -1 && diffY === 0) return EasyStar.LEFT\n        else if (diffX === -1 && diffY === -1) return EasyStar.TOP_LEFT\n        throw new Error('These differences are not valid: ' + diffX + ', ' + diffY)\n    };\n\n    var getTileCost = function(x, y) {\n        return (pointsToCost[y] && pointsToCost[y][x]) || costMap[collisionGrid[y][x]]\n    };\n\n    var coordinateToNode = function(instance, x, y, parent, cost) {\n        if (instance.nodeHash[y] !== undefined) {\n            if (instance.nodeHash[y][x] !== undefined) {\n                return instance.nodeHash[y][x];\n            }\n        } else {\n            instance.nodeHash[y] = {};\n        }\n        var simpleDistanceToTarget = getDistance(x, y, instance.endX, instance.endY);\n        if (parent!==null) {\n            var costSoFar = parent.costSoFar + cost;\n        } else {\n            costSoFar = 0;\n        }\n        var node = new Node(parent,x,y,costSoFar,simpleDistanceToTarget);\n        instance.nodeHash[y][x] = node;\n        return node;\n    };\n\n    var getDistance = function(x1,y1,x2,y2) {\n        if (diagonalsEnabled) {\n            // Octile distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            if (dx < dy) {\n                return DIAGONAL_COST * dx + dy;\n            } else {\n                return DIAGONAL_COST * dy + dx;\n            }\n        } else {\n            // Manhattan distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            return (dx + dy);\n        }\n    };\n}\n\nEasyStar.TOP = 'TOP'\nEasyStar.TOP_RIGHT = 'TOP_RIGHT'\nEasyStar.RIGHT = 'RIGHT'\nEasyStar.BOTTOM_RIGHT = 'BOTTOM_RIGHT'\nEasyStar.BOTTOM = 'BOTTOM'\nEasyStar.BOTTOM_LEFT = 'BOTTOM_LEFT'\nEasyStar.LEFT = 'LEFT'\nEasyStar.TOP_LEFT = 'TOP_LEFT'\n","const MAX_PARKED_BIKES = 4;\n\nclass Cell {\n  constructor(world, type, x, y, allowed_direction) {\n    this.type = type;\n    this.x = x;\n    this.y = y;\n    this.agents = [];\n    this.bikes = 0;\n    this.allowed_direction = allowed_direction;\n  }\n\n  // Check if agent can be added to this cell\n  checkAddAgent(agent) {\n    if (this.type === \"SPAWN\") {\n      return true;\n    }\n\n    if (this.type === \"BUILDING_ENTRANCE\" && agent.type === \"PEDESTRIAN\") {\n      return true;\n    }\n    // Allow a maximum of:\n    // 2 agents of type BIKE\n    // or 3 agents of type PEDESTRIAN\n    // or 1 agent of type BIKE and 2 agents of type PEDESTRIAN\n    // or 2 agent of type BIKE and 1 agents of type PEDESTRIAN\n    if (\n      agent.type === \"BIKE\" &&\n      this.agents.filter(({ type }) => type === \"BIKE\").length >= 20\n    ) {\n      return false;\n    }\n    if (\n      agent.type === \"PEDESTRIAN\" &&\n      this.agents.filter(({ type }) => type === \"PEDESTRIAN\").length >= 30\n    ) {\n      return false;\n    }\n    if (\n      agent.type === \"BIKE\" &&\n      this.agents.filter(({ type }) => type === \"PEDESTRIAN\").length >= 20\n    ) {\n      return false;\n    }\n    if (\n      agent.type === \"PEDESTRIAN\" &&\n      this.agents.filter(({ type }) => type === \"BIKE\").length >= 30\n    ) {\n      return false;\n    }\n    return true;\n  }\n\n  addAgent(agent) {\n    this.agents.push(agent);\n  }\n\n  removeAgent(agent) {\n    this.agents = this.agents.filter((a) => a !== agent);\n  }\n\n  canPark() {\n    return this.type === \"PARKING\" && this.bikes < MAX_PARKED_BIKES;\n  }\n\n  addBike() {\n    this.bikes++;\n  }\n\n  removeBike() {\n    this.bikes--;\n  }\n\n  draw(ctx, x, y, squareSize, drawDirection, drawCoords, drawCount) {\n    const canvas_x = x * squareSize;\n    const canvas_y = y * squareSize;\n\n    let color = \"#fefefe\";\n\n    color = this.getCellColor(color);\n\n    ctx.fillStyle = color;\n    ctx.fillRect(canvas_x, canvas_y, squareSize, squareSize);\n\n    // !! Draws directions in which agents are allowed to move\n    if (drawDirection) {\n      ctx.font = \"16px monospace\";\n      ctx.fillStyle = \"#ffffff\";\n      // make text slightly transparent\n      ctx.globalAlpha = 0.8;\n      let arrow = \"\";\n      if (this.allowed_direction === \"n\") {\n        arrow = \"↑\";\n      } else if (this.allowed_direction === \"s\") {\n        arrow = \"↓\";\n      } else if (this.allowed_direction === \"e\") {\n        arrow = \"→\";\n      } else if (this.allowed_direction === \"w\") {\n        arrow = \"←\";\n      } else if (this.allowed_direction === \"h\") {\n        arrow = \"↔\";\n      } else if (this.allowed_direction === \"v\") {\n        arrow = \"↕\";\n      }\n      ctx.fillText(arrow, canvas_x + 11, canvas_y + 20);\n      // reset transparency\n      ctx.globalAlpha = 1;\n    }\n\n    // Draw progress bar for amount of parked bikes\n    if (this.type === \"PARKING\") {\n      ctx.fillStyle = \"#ffffff\";\n      ctx.fillRect(canvas_x + 2, canvas_y + squareSize - 8, squareSize - 4, 4);\n\n      if (this.bikes == MAX_PARKED_BIKES) {\n        ctx.fillStyle = \"#dc3545\";\n      } else {\n        ctx.fillStyle = \"#316cf4\";\n      }\n      ctx.fillRect(\n        canvas_x + 2,\n        canvas_y + squareSize - 8,\n        (squareSize + 4) * (this.bikes / MAX_PARKED_BIKES),\n        4\n      );\n    }\n\n    if (this.type === \"BUILDING_ENTRANCE\") {\n      ctx.fillStyle = \"#ffffff\";\n      ctx.font = \"16px monospace\";\n      ctx.fillText(\n        \"\" +\n          String(\n            this.agents.filter(({ type }) => type === \"PEDESTRIAN\").length\n          ).padStart(3, \"0\"),\n        canvas_x + 1.5,\n        canvas_y + 21\n      );\n    } else {\n      const bikeAgents = this.agents.filter(({ type }) => type === \"BIKE\");\n      const pedestrianAgents = this.agents.filter(\n        ({ type }) => type === \"PEDESTRIAN\"\n      );\n      if (bikeAgents.length > 0) {\n        bikeAgents.forEach((agent, i) => {\n          // If the current agents is moving to the left or right in the agent's paths next step\n          // then draw the bike in the horizontal position\n          if (\n            agent.path &&\n            agent.path.length > 0 &&\n            agent.path[0].x === agent.cell.x\n          ) {\n            this.drawBike(ctx, x * squareSize, y * squareSize, \"vertical\", i);\n          } else {\n            this.drawBike(ctx, x * squareSize, y * squareSize, \"horizontal\", i);\n          }\n        });\n        if (pedestrianAgents.length > 0) {\n          pedestrianAgents.forEach((agent, i) => {\n            this.drawPedestrian(\n              ctx,\n              x * squareSize + 10,\n              y * squareSize + i * 10\n            );\n          });\n        }\n      } else if (pedestrianAgents.length > 0) {\n        pedestrianAgents.forEach((agent, i) => {\n          if (i < 2) {\n            this.drawPedestrian(ctx, x * squareSize + i * 10, y * squareSize);\n          } else {\n            this.drawPedestrian(ctx, x * squareSize + 5, y * squareSize + 10);\n          }\n        });\n      }\n    }\n\n    //!! Debug to show number of agents in cell\n    if (\n      drawCount &&\n      [\n        \"SPAWN\",\n        \"BIKE_PATH\",\n        \"PEDESTRIAN_PATH\",\n        \"ALL_PATH\",\n        \"PARKING\",\n        \"BUILDING_ENTRANCE\",\n      ].includes(this.type)\n    ) {\n      ctx.font = \"12px monospace\";\n      ctx.fillStyle = \"black\";\n      ctx.globalAlpha = 0.3;\n      ctx.fillText(\n        \"B:\" + this.agents.filter(({ type }) => type === \"BIKE\").length,\n        canvas_x + 2,\n        canvas_y + 12\n      );\n      ctx.fillText(\n        \"P:\" + this.agents.filter(({ type }) => type === \"PEDESTRIAN\").length,\n        canvas_x + 2,\n        canvas_y + 24\n      );\n      ctx.globalAlpha = 1;\n    }\n\n    // !! Draw coordinates\n    if (drawCoords) {\n      ctx.font = \"11px monospace\";\n      ctx.fillStyle = \"black\";\n      ctx.globalAlpha = 0.5;\n      ctx.fillText(this.x + \",\", canvas_x, canvas_y + 10);\n      ctx.fillText(this.y, canvas_x, canvas_y + 22);\n      ctx.globalAlpha = 1;\n    }\n  }\n\n  // Drawing utilities, nothing important after this point :)\n\n  getCellColor(color) {\n    switch (this.type) {\n      case \"SPAWN\":\n        color = \"#e7b1b6\";\n        break;\n      case \"BIKE_PATH\":\n        color = \"#f3d8da\";\n        break;\n      case \"PEDESTRIAN_PATH\":\n        color = \"#eaecef\";\n        break;\n      case \"ALL_PATH\":\n        color = \"#cfd4d9\";\n        break;\n      case \"PARKING\":\n        color = \"#aeb5bc\";\n        break;\n      case \"EMPTY\":\n        color = \"#d5e6de\";\n        break;\n      case \"BUILDING\":\n        color = \"#a6c4f9\";\n        break;\n      case \"BUILDING_ENTRANCE\":\n        color = \"#7ba6f7\";\n        break;\n      case \"EXIT\":\n        color = \"#e7b1b6\";\n        break;\n    }\n    return color;\n  }\n\n  drawBike(ctx, x, y, orientation, i) {\n    ctx.fillStyle = \"#222529\";\n    if (orientation === \"vertical\") {\n      ctx.fillRect(x + 6 + 10 * i, y + 2, 5, 20);\n    } else {\n      ctx.fillRect(x + 2, y + 6 + 10 * i, 20, 5);\n    }\n  }\n\n  drawPedestrian(ctx, x, y) {\n    ctx.fillStyle = \"#fd7e14\";\n    ctx.fillRect(x + 6, y + 2, 5, 5);\n  }\n}\n\nexport default Cell;\n","import { addTimeToPark, addTimeToGoal } from \"./index\";\n\nclass Agent {\n  constructor(world, type, cell, strategy) {\n    this.world = world;\n    this.type = type;\n    this.spawn = cell;\n    this.cell = cell;\n    this.parked_cell = null;\n    this.strategy = strategy;\n    this.move_to = null;\n    this.exitRate = 0.01; // The rate at which agents leave the building across stragegies.\n\n    // This is for storing the calculated path\n    // and not recalculating it every tick\n    this.path = null;\n    this.calculatingPath = false;\n    this.stage = \"SPAWN\";\n\n    this.ticks = 0;\n    this.ticks_to_parked = null;\n    this.ticks_to_goal = null;\n  }\n\n  respawn() {\n    this.stage = \"SPAWN\";\n    this.cell = this.spawn;\n    this.parked_cell = null;\n    this.move_to = null;\n    this.path = null;\n    this.calculatingPath = false;\n    this.ticks = 0;\n    this.ticks_to_parked = null;\n    this.ticks_to_goal = null;\n  }\n\n  getPathfinder() {\n    return this.type === \"BIKE\"\n      ? this.world.bikePathfinder\n      : this.world.pedestrianPathfinder;\n  }\n\n  hasParked() {\n    this.ticks_to_parked = this.ticks;\n    addTimeToPark(this.strategy, this.ticks_to_parked);\n  }\n\n  hasReachedGoal() {\n    this.ticks_to_goal = this.ticks;\n    addTimeToGoal(this.strategy, this.ticks_to_goal);\n  }\n\n  park(location) {\n    if (this.cell.canPark()) {\n      if (\n        this.type === \"BIKE\" &&\n        this.cell.type === \"PARKING\" &&\n        this.parked_cell === null\n      ) {\n        this.parked_cell = this.cell;\n        this.type = \"PEDESTRIAN\";\n        this.cell.addBike();\n        this.world.addLotCapacity(location);\n        this.hasParked();\n        return true;\n      }\n    }\n    return false;\n  }\n\n  unpark(location) {\n    if (\n      this.type === \"PEDESTRIAN\" &&\n      this.cell.type === \"PARKING\" &&\n      this.parked_cell !== null\n    ) {\n      this.cell.removeBike();\n      this.world.removeLotCapacity(location);\n      this.parked_cell = null;\n      this.type = \"BIKE\";\n    }\n  }\n\n  changeMoveTo(x, y, callback) {\n    this.calculatingPath = true;\n    this.move_to = [x, y];\n    this.path = null;\n\n    const pathfinder = this.getPathfinder();\n    pathfinder.findPath(\n      this.cell.x,\n      this.cell.y,\n      this.move_to[0],\n      this.move_to[1],\n      (path) => {\n        if (path !== null) {\n          this.path = path;\n        } else {\n          console.log(\"Agent has no way to reach its goal\");\n        }\n        this.calculatingPath = false;\n        if (callback && path !== null) {\n          callback();\n        }\n      }\n    );\n\n    pathfinder.calculate();\n  }\n\n  makeMove(nextCell) {\n    if (nextCell.checkAddAgent(this)) {\n      this.world.moveAgent(this, nextCell);\n      this.path.shift();\n    }\n  }\n\n  executePathSequence(callback) {\n    if (\n      this.calculatingPath == false &&\n      this.path !== null &&\n      this.path.length > 0\n    ) {\n      const nextCell = this.world.getCellAtCoordinates(\n        this.path[0].x,\n        this.path[0].y\n      );\n      this.makeMove(nextCell);\n    } else if (this.calculatingPath == false) {\n      callback();\n    }\n  }\n\n  finishedParkingStages() {\n    switch (this.stage) {\n      case \"LEAVING_PARKING\":\n        const buildingCell = this.world.getRandomCellOfType(\n          \"BUILDING_ENTRANCE\"\n        );\n        this.changeMoveTo(buildingCell.x, buildingCell.y, () => {\n          this.stage = \"MOVING_TO_GOAL\";\n        });\n        break;\n      case \"MOVING_TO_GOAL\":\n        this.executePathSequence(() => {\n          this.stage = \"IN_GOAL\";\n          this.hasReachedGoal();\n        });\n        break;\n      case \"IN_GOAL\":\n        if (Math.random() < this.exitRate) {\n          this.stage = \"LEAVING_GOAL\";\n        }\n        break;\n      case \"LEAVING_GOAL\":\n        this.changeMoveTo(this.parked_cell.x, this.parked_cell.y, () => {\n          this.stage = \"MOVING_TO_PARKING_LEAVING\";\n        });\n        break;\n      case \"MOVING_TO_PARKING_LEAVING\":\n        this.executePathSequence(() => {\n          this.stage = \"UNPARKING\";\n        });\n        break;\n      case \"UNPARKING\":\n        this.unpark(this.lotChoice);\n        this.stage = \"LEAVING\";\n        break;\n      case \"LEAVING\":\n        this.changeMoveTo(this.spawn.x, this.spawn.y, () => {\n          this.stage = \"MOVING_TO_EXIT\";\n        });\n        break;\n      case \"MOVING_TO_EXIT\":\n        this.executePathSequence(() => {\n          this.stage = \"DESPAWN\";\n        });\n        break;\n      case \"DESPAWN\":\n        this.stage = \"SPAWN\";\n        this.world.removeAgent(this);\n        break;\n      default:\n        console.log(\"Unknown stage: \", this.stage);\n        break;\n    }\n  }\n\n  ////////////////////////\n  // STRATEGY EXECUTION //\n  ////////////////////////\n\n  startAct() {\n    this.ticks += 1;\n  }\n\n  act() {\n    console.warn(\"Agent.act() should be overridden\");\n  }\n}\n\nexport default Agent;\n","import Agent from \"../Agent\";\n\nclass SmartAgent extends Agent {\n  constructor(world, type, cell) {\n    super(world, type, cell, \"SMART\");\n\n    // Variables relating to lot preferences.\n    this.lots = [\"north\", \"east\", \"mid\", \"west\"];\n    this.lotChoice = null;\n    // NORTH, EAST, MID, WEST\n    this.lotPreference = [\n      Math.random(),\n      Math.random(),\n      Math.random(),\n      Math.random(),\n    ];\n    this.changePreference = 0.01; // The amount preference changes upon update.\n\n    // Variables for searching in lot.\n    this.searchPath = [];\n    this.searchTime = 6; // Tolances to look for a spot to park. Changes lot when searchFail == searchTime\n    this.searchFail = 0;\n  }\n\n  ////////////////////////\n  // STRATEGY EXECUTION //\n  ////////////////////////\n\n  // AUXILIARY FUNCTIONS //\n  randomValueInRange(min, max) {\n    return Math.floor(Math.random() * (max - min) + min);\n  }\n\n  // Just returns the coordinates of a random parking spot depending on the location called.\n  randomLotCoordinates(location) {\n    // Returns random parking coordinates at the given location.\n    var coordinates = new Array(1);\n\n    if (location == \"north\") {\n      coordinates[0] = this.randomValueInRange(20, 30);\n      coordinates[1] = this.randomValueInRange(4, 7);\n    }\n    if (location == \"east\") {\n      coordinates[0] = this.randomValueInRange(23, 29);\n      if (Math.random() < 0.66) {\n        coordinates[1] = this.randomValueInRange(19, 21);\n      } else {\n        coordinates[1] = 23;\n      }\n    }\n    if (location == \"mid\") {\n      coordinates[0] = this.randomValueInRange(10, 17);\n      coordinates[1] = this.randomValueInRange(17, 19);\n    }\n    if (location == \"west\") {\n      coordinates[0] = this.randomValueInRange(4, 6);\n      coordinates[1] = this.randomValueInRange(17, 20);\n    }\n\n    return coordinates;\n  }\n\n  // THIS SEARCH IS SHIT. ONE OPTION IS TO ADD DFS TO SEARCH SURROUDNINGS.\n  lotSearch() {\n    var coordinates = new Array(1);\n    console.log(\"Got into the lot search\");\n    var goal_cell = this.world.getCellAtCoordinates(this.move_to[0], this.move_to[1]);\n    console.log(\"Not here\");\n\n    if (this.world.state[goal_cell.y][goal_cell.x + 1].type == \"PARKING\" && goal_cell.canPark()) {\n      coordinates[0] = goal_cell.x + 1;\n      coordinates[1] = goal_cell.y;\n    } else if (\n      this.world.state[goal_cell.y][goal_cell.x - 1].type == \"PARKING\" && goal_cell.canPark()\n    ) {\n      coordinates[0] = goal_cell.x - 1;\n      coordinates[1] = goal_cell.y;\n    } else if (\n      this.world.state[goal_cell.y - 1][goal_cell.x].type == \"PARKING\" && goal_cell.canPark()\n    ) {\n      coordinates[0] = goal_cell.x;\n      coordinates[1] = goal_cell.y - 1;\n    } else if (\n      this.world.state[goal_cell.y + 1][goal_cell.x].type == \"PARKING\" && goal_cell.canPark()\n    ) {\n      coordinates[0] = goal_cell.x;\n      coordinates[1] = goal_cell.y - 1;\n    } else {\n      this.searchPath.pop(coordinates);\n      return coordinates;\n    }\n\n    this.searchPath.push(coordinates);\n    return coordinates;\n  }\n\n  // Returns the preference with the highest value.\n  checkPreference() {\n    var maxPref = Math.max(...this.lotPreference);\n    var index = this.lotPreference.indexOf(maxPref);\n    return this.lots[index];\n  }\n\n  // Basically the update functions for the agents. This one increases one option and decreases the others.\n  increasePreference(location) {\n    var index = this.lots.indexOf(location);\n\n    for (let i = 0; i < this.lots.length; i++) {\n      if (i == index) {\n        this.lotPreference[i] += this.changePreference;\n      } else {\n        this.lotPreference[i] -= this.changePreference;\n      }\n\n      this.lotPreference[i] = Math.round(this.lotPreference[i] * 100.0) / 100.0;\n\n      this.lotPreference[i] =\n        this.lotPreference[i] > 1\n          ? (this.lotPreference[i] = 1)\n          : this.lotPreference[i];\n\n      this.lotPreference[i] =\n        this.lotPreference[i] < 0\n          ? (this.lotPreference[i] = 0)\n          : this.lotPreference[i];\n    }\n  }\n\n  // Basically the update functions for the agents. This one decreases one option and increases the others.\n  decreasePreference(location) {\n    var index = this.lots.indexOf(location);\n\n    for (let i = 0; i < this.lots.length; i++) {\n      if (i == index) {\n        this.lotPreference[i] -= this.changePreference;\n      } else {\n        this.lotPreference[i] += this.changePreference;\n      }\n\n      this.lotPreference[i] = Math.round(this.lotPreference[i] * 100.0) / 100.0;\n\n      this.lotPreference[i] =\n        this.lotPreference[i] > 1\n          ? (this.lotPreference[i] = 1)\n          : this.lotPreference[i];\n\n      this.lotPreference[i] =\n        this.lotPreference[i] < 0\n          ? (this.lotPreference[i] = 0)\n          : this.lotPreference[i];\n    }\n  }\n\n  // SMART STRATEGY //\n  act() {\n    this.startAct();\n\n    switch (this.stage) {\n      case \"SPAWN\":\n        this.lotChoice = this.checkPreference();\n        var coordinates = this.randomLotCoordinates(this.lotChoice);\n\n        this.changeMoveTo(coordinates[0], coordinates[1], () => {\n          this.stage = \"MOVE_TO_LOT\";\n        });\n        break;\n      case \"CHANGE_CHOICE\":\n        this.decreasePreference(this.lotChoice);\n\n        while (true) {\n          var choice = this.lots[Math.floor(Math.random() * this.lots.length)];\n\n          if (choice != this.lotChoice) {\n            this.lotChoice = choice;\n            break;\n          }\n        }\n\n        var coordinates = this.randomLotCoordinates(this.lotChoice);\n        this.changeMoveTo(coordinates[0], coordinates[1], () => {\n          this.stage = \"MOVE_TO_LOT\";\n        });\n        break;\n      case \"MOVE_TO_LOT\":\n        if (\n          this.calculatingPath == false &&\n          this.path !== null &&\n          this.path.length > 0\n        ) {\n          const nextCell = this.world.getCellAtCoordinates(\n            this.path[0].x,\n            this.path[0].y\n          );\n          this.makeMove(nextCell);\n\n          if (this.path.length < 5) {\n            this.stage = \"EVALUATE_LOT\";\n          } else if (this.path.length < 2){\n            var goal_cell = this.world.getCellAtCoordinates(this.move_to[0], this.move_to[1]);\n            if(!goal_cell.canPark()){\n              this.stage = \"SEARCHING_IN_LOT\"\n            }\n          }\n        } else if (this.calculatingPath == false) {\n          this.stage = \"PARKING\";\n        }\n        break;\n      case \"EVALUATE_LOT\":\n        if (this.world.getLotCapacity(this.lotChoice) > 0.8) {\n          this.stage = \"CHANGE_CHOICE\";\n        } else {\n          this.stage = \"MOVE_TO_LOT\";\n        }\n        break;\n      case \"SEARCHING_IN_LOT\":\n        var coordinates = this.lotSearch();\n        this.changeMoveTo(coordinates[0], coordinates[1], () => {\n          this.stage = \"MOVE_TO_LOT\";\n        });\n        break;\n      case \"PARKING\":\n        if (this.park(this.lotChoice)) {\n          this.stage = \"LEAVING_PARKING\";\n          this.increasePreference(this.lotChoice);\n        } else {\n          // console.warn(\"Could not park\");\n          this.searchFail += 1;\n          if (this.searchFail > this.searchTime) {\n            this.stage = \"CHANGE_CHOICE\";\n            this.searchFail = 0;\n          } else {\n            this.stage = \"SEARCHING_IN_LOT\";\n          }\n        }\n        break;\n      default:\n        this.finishedParkingStages();\n        break;\n    }\n  }\n}\n\nexport default SmartAgent;\n","import Agent from \"../Agent\";\n\nclass RandomAgent extends Agent {\n  constructor(world, type, cell) {\n    super(world, type, cell, \"RANDOM\");\n  }\n\n  act() {\n    this.startAct();\n\n    switch (this.stage) {\n      case \"SPAWN\":\n        const parkingCell = this.world.getRandomCellOfType(\"PARKING\");\n        this.changeMoveTo(parkingCell.x, parkingCell.y, () => {\n          this.stage = \"MOVING_TO_PARKING_ENTERING\";\n        });\n        break;\n      case \"MOVING_TO_PARKING_ENTERING\":\n        this.executePathSequence(() => {\n          this.stage = \"PARKING\";\n        });\n        break;\n      case \"PARKING\":\n        if (this.park()) {\n          this.stage = \"LEAVING_PARKING\";\n        } else {\n          this.stage = \"SPAWN\";\n        }\n        break;\n      default:\n        this.finishedParkingStages();\n        break;\n    }\n  }\n}\n\nexport default RandomAgent;\n","import Agent from \"../Agent\";\n\nclass ClosestAgent extends Agent {\n  constructor(world, type, cell) {\n    super(world, type, cell, \"CLOSEST\");\n  }\n\n  act() {\n    this.startAct();\n\n    switch (this.stage) {\n      case \"SPAWN\":\n        // BFS for the closest valid parking spot\n        let coords = { x: 0, y: 0 };\n        let Q = [];\n        let grid = [];\n        const label = function (x, y) {\n          grid[y] ??= [];\n          grid[y][x] = 1;\n        };\n        label(this.cell.x, this.cell.y);\n        Q = [[this.cell.x, this.cell.y], ...Q];\n        BFS: while (Q.length) {\n          const V = Q.pop();\n          const cell = this.world.getCellAtCoordinates(V[0], V[1]);\n          if (cell.canPark()) {\n            coords = { x: V[0], y: V[1] };\n            break BFS;\n          }\n          const dirs = [\n            [V[1], V[0] + 1],\n            [V[1], V[0] - 1],\n            [V[1] + 1, V[0]],\n            [V[1] - 1, V[0]],\n          ];\n          for (const [y, x] of dirs) {\n            let next = this.world.state[y]?.[x];\n            let valid_types = [\n              \"SPAWN\",\n              \"BIKE_PATH\",\n              \"ALL_PATH\",\n              \"PARKING\",\n              \"EXIT\",\n            ];\n            if (\n              next !== undefined &&\n              valid_types.includes(next.type) &&\n              grid[y]?.[x] !== 1\n            ) {\n              label(x, y);\n              Q = [[x, y], ...Q];\n            }\n          }\n        }\n        this.changeMoveTo(coords.x, coords.y, () => {\n          this.stage = \"MOVING_TO_PARKING_ENTERING\";\n        });\n        break;\n\n      case \"MOVING_TO_PARKING_ENTERING\":\n        this.executePathSequence(() => {\n          this.stage = \"PARKING\";\n        });\n        break;\n\n      case \"PARKING\":\n        if (this.park()) {\n          this.stage = \"LEAVING_PARKING\";\n        } else {\n          this.stage = \"SPAWN\";\n        }\n        break;\n\n      default:\n        this.finishedParkingStages();\n        break;\n    }\n  }\n}\n\nexport default ClosestAgent;\n","import EasyStar from \"easystarjs\";\n\nimport Cell from \"./Cell\";\n\nimport Agent from \"./Agent\";\nimport SmartAgent from \"./Agents/SmartAgent\";\nimport RandomAgent from \"./Agents/RandomAgent\";\nimport ClosestAgent from \"./Agents/ClosestAgent\";\n\nfunction getDirectionArray(direction) {\n  switch (direction) {\n    case \"n\":\n      return [EasyStar.BOTTOM];\n    case \"s\":\n      return [EasyStar.TOP];\n    case \"e\":\n      return [EasyStar.LEFT];\n    case \"w\":\n      return [EasyStar.RIGHT];\n    case \"v\":\n      return [EasyStar.TOP, EasyStar.BOTTOM];\n    case \"h\":\n      return [EasyStar.LEFT, EasyStar.RIGHT];\n    default:\n      return [EasyStar.TOP, EasyStar.BOTTOM, EasyStar.LEFT, EasyStar.RIGHT];\n  }\n}\n\nclass World {\n  constructor(worldmap, mapDirection, selectedStrategies) {\n    this.state = [];\n    this.agentsActive = []; // Agents that are currently in the world.\n    this.agentsInactive = []; // Agents that are not currecntly in the world.\n\n    // This keeps track how full the lots are.\n    this.northCapacity = 0;\n    this.eastCapacity = 0;\n    this.midCapacity = 0;\n    this.westCapacity = 0;\n\n    this.tickCount = 0;\n\n    // Setup initial state\n    const rows = worldmap.split(\"\\n\").filter((row) => row.length > 0);\n    const directionRows = mapDirection\n      .split(\"\\n\")\n      .filter((row) => row.length > 0);\n\n    // Turns the characters from the worldmap into understandable strings\n    const types = {\n      // Useful stuff\n      S: \"SPAWN\",\n      E: \"EXIT\",\n      X: \"BUILDING_ENTRANCE\",\n      b: \"BIKE_PATH\",\n      w: \"PEDESTRIAN_PATH\",\n      a: \"ALL_PATH\",\n      p: \"PARKING\",\n      // Cosmetics\n      _: \"EMPTY\",\n      o: \"BUILDING\",\n    };\n\n    this.bikePathfinder = new EasyStar.js();\n    this.pedestrianPathfinder = new EasyStar.js();\n\n    // Create cells\n    // Loop over the 2D array of types, and create a new cell for each type\n    for (const [y, row] of rows.entries()) {\n      const directionRow = [...directionRows[y]];\n      const rowData = [...row].map((c, x) => {\n        const allowed_direction = directionRow[x];\n        const type = types[c];\n        const cell = new Cell(this, type, x, y, allowed_direction);\n\n        this.bikePathfinder.setDirectionalCondition(\n          x,\n          y,\n          getDirectionArray(allowed_direction)\n        );\n        this.pedestrianPathfinder.setDirectionalCondition(\n          x,\n          y,\n          getDirectionArray(allowed_direction)\n        );\n\n        return cell;\n      });\n      this.state.push(rowData);\n    }\n\n    this.bikePathfinder.setGrid(\n      this.state.map((row) => row.map((cell) => cell.type))\n    );\n    this.bikePathfinder.setAcceptableTiles([\n      \"SPAWN\",\n      \"BIKE_PATH\",\n      \"ALL_PATH\",\n      \"PARKING\",\n      \"EXIT\",\n    ]);\n    this.bikePathfinder.setTileCost(\"ALL_PATH\", 2);\n    this.bikePathfinder.setTileCost(\"PARKING\", 4);\n\n    this.pedestrianPathfinder.setGrid(\n      this.state.map((row) => row.map((cell) => cell.type))\n    );\n    this.pedestrianPathfinder.setAcceptableTiles([\n      \"PEDESTRIAN_PATH\",\n      \"ALL_PATH\",\n      \"PARKING\",\n      \"BUILDING_ENTRANCE\",\n    ]);\n    this.pedestrianPathfinder.setTileCost(\"ALL_PATH\", 2);\n    this.pedestrianPathfinder.setTileCost(\"PARKING\", 3);\n  }\n\n  getCellAtCoordinates(x, y) {\n    return this.state[y][x];\n  }\n\n  getRandomCellOfType(type) {\n    const cells = this.state.flat().filter((cell) => cell.type === type);\n    return cells[Math.floor(Math.random() * cells.length)];\n  }\n\n  getParkingLots() {\n    return this.state.flat().filter((cell) => cell.type === \"PARKING\");\n  }\n\n  // These capacity functions evaulate the amount of bikes park in lots.\n  addLotCapacity(location) {\n    if (location == \"north\") {\n      this.northCapacity += 1;\n    }\n    if (location == \"east\") {\n      this.eastCapacity += 1;\n    }\n    if (location == \"mid\") {\n      this.midCapacity += 1;\n    }\n    if (location == \"west\") {\n      this.westCapacity += 1;\n    }\n  }\n\n  removeLotCapacity(location) {\n    if (location == \"north\") {\n      this.northCapacity -= 1;\n    }\n    if (location == \"east\") {\n      this.eastCapacity -= 1;\n    }\n    if (location == \"mid\") {\n      this.midCapacity -= 1;\n    }\n    if (location == \"west\") {\n      this.westCapacity -= 1;\n    }\n  }\n\n  getLotCapacity(location) {\n    if (location == \"north\") {\n      return this.northCapacity / 120;\n    }\n    if (location == \"east\") {\n      return this.eastCapacity / 72;\n    }\n    if (location == \"mid\") {\n      return this.midCapacity / 56;\n    }\n    if (location == \"west\") {\n      return this.westCapacity / 24;\n    }\n  }\n\n  getAgentClass(stragegy) {\n    switch (stragegy) {\n      case \"SMART\":\n        return SmartAgent;\n      case \"RANDOM\":\n        return RandomAgent;\n      case \"CLOSEST\":\n        return ClosestAgent;\n      default:\n        return Agent;\n    }\n  }\n\n  // Adds a new agent to the world, at a random spawn point\n  spawnAgent(strategy) {\n    // Find if there is an inactive agent with the same strategy\n    const oldAgent = this.agentsInactive.find(\n      (agent) => agent.strategy === strategy\n    );\n\n    // If there is an inactive agent, activate it\n    if (oldAgent) {\n      this.agentsActive.push(oldAgent);\n      this.agentsInactive = this.agentsInactive.filter((a) => oldAgent !== a);\n      oldAgent.spawn.addAgent(oldAgent);\n      oldAgent.respawn();\n    } else {\n      // If there is no inactive agent, create a new one\n      // Randomly pick a spawn cell\n      const spawn = this.getRandomCellOfType(\"SPAWN\");\n      const AgentClass = this.getAgentClass(strategy);\n      const newAgent = new AgentClass(this, \"BIKE\", spawn);\n      this.agentsActive.push(newAgent);\n      spawn.addAgent(newAgent);\n    }\n  }\n\n  // Remove agent from world\n  removeAgent(agent) {\n    this.agentsActive = this.agentsActive.filter((a) => a !== agent);\n    agent.cell.removeAgent(agent);\n    this.agentsInactive.push(agent);\n  }\n\n  // Moves agent to a new cell\n  moveAgent(agent, cell) {\n    if (cell.checkAddAgent(agent)) {\n      agent.cell.removeAgent(agent);\n      cell.addAgent(agent);\n      agent.cell = cell;\n    }\n  }\n\n  tick() {\n    this.tickCount++;\n    this.agentsActive.sort(function () {\n      return 0.5 - Math.random();\n    });\n    for (const agent of this.agentsActive) {\n      if (agent.type === \"BIKE\") {\n        agent.act();\n      } else if (agent.type === \"PEDESTRIAN\" && this.tickCount % 2 === 0) {\n        agent.act();\n      }\n    }\n  }\n}\n\nexport default World;\n","import \"./styles.css\";\nimport worldmap, { mapDirection } from \"./map\";\n\nimport World from \"./World\";\n\n// **********************************\n// Static config variables\n// **********************************\nconst experimentTicks = 10000;\nconst automatedLoopLength = 500;\nconst maxSpawnRateLimit = 1;\n\n// **********************************\n// Parameter variable setup\n// **********************************\n\nconst STRATEGIES = [\"SMART\", \"RANDOM\", \"CLOSEST\"];\n\n// Set default selected strategies\nlet selectedStrategies = [\"SMART\", \"RANDOM\", \"CLOSEST\"];\n\nvar currentTick = 0;\n\nvar csvRowsPark = \"strategy,time\\n\";\nvar csvRowsGoal = \"strategy,time\\n\";\n\nvar timeToParkData = [selectedStrategies];\nvar timeToGoalData = [selectedStrategies];\nvar trendData = {};\n// Add key to trendData for selectedStrategies\nfunction clearTrendData() {\n  trendData = {};\n  selectedStrategies.forEach((strategy) => {\n    trendData[strategy] = [];\n  });\n}\nclearTrendData();\n\nvar experimentMode = false;\n\nlet spawnRateType = \"auto\";\n\n// Config for automated spawn rate\nconst minSpawnRate = 0.2;\nvar maxSpawnRate = 1;\n\n// Default tickDelay and spawnspeed\nlet tickDelay = 20;\nlet oldTickDelay = tickDelay;\nlet spawnspeed = 0.2;\n\nlet paused = false;\n\n// **********************************\n// Utility functions\n// **********************************\n\n// Reset keeps current settings, but clears the world and restarts the simulation\nfunction reset() {\n  world = new World(worldmap, mapDirection);\n  timeToParkData = [selectedStrategies];\n  timeToGoalData = [selectedStrategies];\n  clearTrendData();\n  csvRowsPark = \"strategy,time\\n\";\n  csvRowsGoal = \"strategy,time\\n\";\n  currentTick = 0;\n  experimentMode = false;\n}\n\n// Turns stragegy name into a nice display name\nfunction strategyName(strategy) {\n  return strategy\n    .toLowerCase()\n    .replace(/^_*(.)|_+(.)/g, (s, c, d) =>\n      c ? c.toUpperCase() : \" \" + d.toUpperCase()\n    );\n}\n\n// Onclick of #experiment-mode, start experiment\ndocument.getElementById(\"experiment-mode\").onclick = function () {\n  reset();\n  tickDelay = 0;\n  experimentMode = true;\n  paused = false;\n};\n\n// **********************************\n// User Controls\n// **********************************\n\n// -- Spawn rate control\n// **********************************\n\n// return value for current bin using sine wave between min and max, over length of automatedLoopLength\nfunction getSpawnRate(currentBin) {\n  return (\n    minSpawnRate +\n    (maxSpawnRate - minSpawnRate) *\n    Math.pow(\n      (Math.sin((currentBin / automatedLoopLength) * 2 * Math.PI) + 1) / 2,\n      2\n    )\n  );\n}\n\n// Create array of spawn rates of length automated_loop_length\nlet spawnRates = [];\nfunction updateSpawnRates() {\n  spawnRates = [];\n  for (var i = 0; i < automatedLoopLength; i++) {\n    spawnRates.push(getSpawnRate(i));\n  }\n}\nupdateSpawnRates();\n\n// Draw bars for spawn_rate on canvas\nfunction drawSpawnRate(currentTick) {\n  document.getElementById(\"automated-spawn-rate-display\").innerHTML =\n    Math.floor(spawnRates[currentTick % automatedLoopLength] * 100) + \"%\";\n  const canvas = document.getElementById(\"spawn-rate\");\n  const ctx = canvas.getContext(\"2d\");\n  const width = canvas.width;\n  const height = canvas.height;\n  const barWidth = width / automatedLoopLength;\n  const barHeight = height / maxSpawnRateLimit;\n  ctx.clearRect(0, 0, width, height);\n  ctx.fillStyle = \"#fbe7a5\";\n  ctx.fillRect(0, 0, width, height);\n\n  // Plot bar for spawn rate at corresponding tick\n  for (var i = 0; i < automatedLoopLength; i++) {\n    ctx.fillStyle = \"#f6c344\";\n    ctx.fillRect(\n      i * barWidth,\n      height - spawnRates[i] * barHeight,\n      barWidth,\n      spawnRates[i] * barHeight\n    );\n  }\n\n  // Plot a line every 20%\n  for (var i = 0; i < maxSpawnRateLimit; i += 0.2) {\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = \"#c49c35\";\n    ctx.beginPath();\n    ctx.moveTo(0, height - i * barHeight);\n    ctx.lineTo(width, height - i * barHeight);\n    ctx.stroke();\n    // Add text\n    ctx.fillStyle = \"#c49c35\";\n    ctx.font = \"20px Arial\";\n    ctx.fillText(\n      Math.floor(i * 100) + \"%\",\n      width - 42,\n      height - i * barHeight - 3\n    );\n  }\n\n  // Plot the current spawn rate\n  const currentIndex = currentTick % automatedLoopLength;\n  ctx.fillStyle = \"#312708\";\n  ctx.fillRect(\n    currentIndex * barWidth,\n    height - spawnRates[currentIndex] * barHeight - 2,\n    barWidth * 4,\n    spawnRates[currentIndex] * barHeight + 2\n  );\n  // Draw small circle on top of line\n  ctx.beginPath();\n  ctx.arc(\n    currentIndex * barWidth + barWidth * 2,\n    height - spawnRates[currentIndex] * barHeight,\n    5,\n    0,\n    2 * Math.PI\n  );\n  ctx.fill();\n}\ndrawSpawnRate(currentTick);\n\ndocument.getElementById(\"spawnspeed\").addEventListener(\"input\", (e) => {\n  spawnspeed = e.target.value;\n  document.getElementById(\"manual-spawn-rate-display\").innerHTML =\n    Math.round(spawnspeed * 100) + \"%\";\n});\n\n// Switch between spawn rate types\ndocument\n  .getElementById(\"spawnrate-radio-auto\")\n  .addEventListener(\"change\", function (event) {\n    spawnRateType = event.target.value;\n    document.getElementById(\"spawnspeed\").disabled = true;\n  });\ndocument\n  .getElementById(\"spawnrate-radio-manual\")\n  .addEventListener(\"change\", function (event) {\n    spawnRateType = event.target.value;\n    document.getElementById(\"spawnspeed\").disabled = false;\n  });\n\n// Switch between max_spawn_rate value\ndocument\n  .getElementById(\"automatedPeak1\")\n  .addEventListener(\"change\", function (event) {\n    maxSpawnRate = 1;\n    updateSpawnRates();\n  });\ndocument\n  .getElementById(\"automatedPeak2\")\n  .addEventListener(\"change\", function (event) {\n    maxSpawnRate = 0.66;\n    updateSpawnRates();\n  });\ndocument\n  .getElementById(\"automatedPeak3\")\n  .addEventListener(\"change\", function (event) {\n    maxSpawnRate = 0.33;\n    updateSpawnRates();\n  });\n\n// -- Reset button\n// **********************************\n\ndocument.getElementById(\"reset\").addEventListener(\"click\", () => {\n  reset();\n});\n\n// -- Strategy selection\n// **********************************\n\n// Create HTML checkboxes for each strategy, and add them and remove them to selectedStrategies when enabled/disabled\nconst strategyCheckboxes = document.getElementById(\"strategy-checkboxes\");\nSTRATEGIES.forEach((strategy) => {\n  const container = document.createElement(\"div\");\n  container.classList.add(\"form-check\");\n  const checkbox = document.createElement(\"input\");\n  checkbox.classList.add(\"form-check-input\");\n  checkbox.type = \"checkbox\";\n  checkbox.id = strategy;\n  checkbox.checked = selectedStrategies.includes(strategy);\n  checkbox.addEventListener(\"change\", () => {\n    if (checkbox.checked) {\n      selectedStrategies.push(strategy);\n    } else {\n      selectedStrategies = selectedStrategies.filter((s) => s !== strategy);\n    }\n    reset();\n  });\n  const label = document.createElement(\"label\");\n  label.htmlFor = strategy;\n  label.classList.add(\"form-check-label\");\n  label.appendChild(document.createTextNode(strategyName(strategy)));\n  strategyCheckboxes.appendChild(container);\n  container.appendChild(checkbox);\n  container.appendChild(label);\n});\n\n// -- Play/pause button\n// **********************************\n\ndocument.getElementById(\"play-pause\").addEventListener(\"click\", () => {\n  if (document.getElementById(\"play-pause\").innerHTML === \"Play\") {\n    document.getElementById(\"play-pause\").innerHTML = \"Pause\";\n    paused = false;\n  } else {\n    document.getElementById(\"play-pause\").innerHTML = \"Play\";\n    paused = true;\n  }\n});\n\n// -- Tickdelay\n// **********************************\ndocument.getElementById(\"tickdelay\").addEventListener(\"input\", (e) => {\n  tickDelay = e.target.value;\n});\n\n// -- Display options\n// **********************************\nvar drawDirection = false;\nvar drawCoords = false;\nvar drawCount = false;\n\ndocument.getElementById(\"draw-direction\").addEventListener(\"change\", (e) => {\n  drawDirection = e.target.checked;\n});\ndocument.getElementById(\"draw-coords\").addEventListener(\"change\", (e) => {\n  drawCoords = e.target.checked;\n});\ndocument.getElementById(\"draw-count\").addEventListener(\"change\", (e) => {\n  drawCount = e.target.checked;\n});\n\n// **********************************\n// Data gathering functions used by the agents\n// **********************************\n\nexport function addTimeToPark(strategy, data) {\n  const index = selectedStrategies.indexOf(strategy);\n  const row = Array(selectedStrategies.length).fill(null);\n  row[index] = data;\n  timeToParkData.push(row);\n  csvRowsPark += `${strategy},${data}\\n`;\n}\n\nexport function addTimeToGoal(strategy, data) {\n  const index = selectedStrategies.indexOf(strategy);\n  const row = Array(selectedStrategies.length).fill(null);\n  row[index] = data;\n  timeToGoalData.push(row);\n  trendData[strategy].push(data);\n  csvRowsGoal += `${strategy},${data}\\n`;\n}\n\n// **********************************\n// Results modal\n// **********************************\n\ngoogle.charts.load(\"current\", { packages: [\"corechart\"] });\ngoogle.charts.setOnLoadCallback(() => {\n  DrawChart(\"time-to-park\", timeToParkData, 0);\n  DrawChart(\"time-to-goal\", timeToGoalData, 0);\n  DrawTrend(trendData);\n});\n// Render charts onclick of #render-charts\ndocument.getElementById(\"render-charts\").addEventListener(\"click\", () => {\n  openResultsModal();\n});\ndocument.getElementById(\"closeResultsModal\").addEventListener(\"click\", () => {\n  closeResultsModal();\n});\n\nfunction openResultsModal() {\n  // Get maximum value of combined timeToParkData and timeToGoalData\n  let max = 0;\n  timeToParkData.forEach((row) => {\n    if (row[1] > max) {\n      max = row[1];\n    }\n  });\n  timeToGoalData.forEach((row) => {\n    if (row[1] > max) {\n      max = row[1];\n    }\n  });\n\n  DrawChart(\"time-to-park\", timeToParkData, max);\n  DrawChart(\"time-to-goal\", timeToGoalData, max);\n  DrawTrend(trendData);\n  document.getElementById(\"resultsModal\").style.display = \"block\";\n  document.getElementById(\"resultsModalBackdrop\").style.display = \"block\";\n  oldTickDelay = tickDelay;\n  paused = true;\n}\nfunction closeResultsModal() {\n  document.getElementById(\"resultsModal\").style.display = \"none\";\n  document.getElementById(\"resultsModalBackdrop\").style.display = \"none\";\n  tickDelay = oldTickDelay;\n  paused = false;\n}\n\nfunction DrawChart(id, data, max) {\n  // Create the data table.\n  var data = google.visualization.arrayToDataTable(data);\n\n  // Set chart options\n  var options = {\n    width: \"1100\",\n    height: 300,\n    bar: { gap: 0 },\n    interpolateNulls: false,\n    chartArea: { left: 10, top: 0, bottom: 35 },\n    histogram: {\n      bucketSize: 20,\n      maxNumBuckets: 50,\n      minValue: 0,\n      maxValue: max,\n      lastBucketPercentile: 5,\n    },\n  };\n\n  // Instantiate and draw our chart, passing in some options.\n  var chart = new google.visualization.Histogram(document.getElementById(id));\n  chart.draw(data, options);\n}\n\nfunction DrawTrend(data) {\n  // Create new data table, with a column for each strategy\n  const dataRows = [];\n  const strategies = Object.keys(data);\n  // Average the data for each strategy per `automatedLoopLength` ticks\n  strategies.forEach((strategy) => {\n    const strategyData = data[strategy];\n    const averagedData = [];\n    for (let i = 0; i < strategyData.length; i += automatedLoopLength) {\n      const slice = strategyData.slice(i, i + automatedLoopLength);\n      const average = slice.reduce((a, b) => a + b, 0) / slice.length;\n      averagedData.push(average);\n    }\n    dataRows.push(averagedData);\n  });\n\n  console.log(dataRows);\n\n  // Find strategy with most data points, loop over this and create a row for each datapoint for all strategies at this index\n  const maxDataPoints = Math.max(...dataRows.map((row) => row.length));\n  const dataCombined = [];\n  for (let i = 0; i < maxDataPoints; i++) {\n    const row = [];\n    strategies.forEach((strategy, index) => {\n      row.push(dataRows[index][i] || null);\n    });\n    dataCombined.push(row);\n  }\n\n  const dataColumns = [[\"X\", ...strategies]];\n  dataCombined.forEach((row, index) => {\n    dataColumns.push([index, ...row]);\n  });\n  console.log(dataCombined)\n  var data = google.visualization.arrayToDataTable(dataColumns);\n\n  console.log(data);\n  // Trendline configuration for each strategy\n  const trendlines = {};\n  strategies.forEach((strategy, i) => {\n    trendlines[i] = {\n      type: \"exponential\",\n      visibleInLegend: true,\n      // opacity: 1,\n    };\n  });\n\n  var trendOptions = {\n    width: \"1100\",\n    height: 300,\n    bar: { gap: 0 },\n    interpolateNulls: false,\n    chartArea: { left: 10, top: 0, bottom: 35 },\n    trendlines: trendlines,\n    // dataOpacity: 0.1,\n    explorer: {},\n  };\n  var trendChart = new google.visualization.LineChart(document.getElementById(\"trend-time-to-goal\"));\n  trendChart.draw(data, trendOptions);\n}\n\n// **********************************\n// Read worldmap and create worldData\n// **********************************\n\nlet world = new World(worldmap, mapDirection);\n\n// **********************************\n// This runs the simulation loop every tick\n// **********************************\n\nfunction gameTick() {\n  if (!paused) {\n    // Spawn new agent sometimes\n    let rate = spawnspeed;\n    if (spawnRateType === \"auto\") {\n      rate = spawnRates[currentTick % automatedLoopLength];\n    }\n\n    if (Math.random() < rate) {\n      // Pick random strategy from selectedStrategies\n      if (selectedStrategies.length > 0) {\n        const strategy =\n          selectedStrategies[\n          Math.floor(Math.random() * selectedStrategies.length)\n          ];\n        world.spawnAgent(strategy);\n      }\n    }\n\n    // Move current agents\n    world.tick();\n    currentTick++;\n    drawSpawnRate(currentTick);\n    if (experimentMode) {\n      document.getElementById(\"experiment-progress\").style.width =\n        (currentTick / experimentTicks) * 100 + \"%\";\n    }\n    if (experimentMode && currentTick > experimentTicks) {\n      openResultsModal();\n      document.getElementById(\"experiment-progress\").style.width = \"0%\";\n      experimentMode = false;\n    }\n  }\n  setTimeout(gameTick, tickDelay);\n}\n\ngameTick();\n\n// **********************************\n// Draw world state to canvas\n// **********************************\n\nconst squareSize = 32;\n\nconst gridWidth = world.state[0].length;\nconst gridHeight = world.state.length;\n\nconst canvasWidth = gridWidth * squareSize;\nconst canvasHeight = gridHeight * squareSize;\n\nvar c = document.getElementById(\"canvas\");\nvar ctx = c.getContext(\"2d\");\nctx.canvas.width = canvasWidth;\nctx.canvas.height = canvasHeight;\n\nfunction drawCanvas() {\n  for (const [y, row] of world.state.entries()) {\n    for (const [x, cell] of row.entries()) {\n      cell.draw(ctx, x, y, squareSize, drawDirection, drawCoords, drawCount);\n    }\n  }\n  requestAnimationFrame(drawCanvas);\n}\n\nrequestAnimationFrame(drawCanvas);\n\n// **********************************\n// Download CSV data to file\n// **********************************\n\n// When button with id \"export-park\" is clicked, download the csv file with the data\ndocument.getElementById(\"export-park\").addEventListener(\"click\", () => {\n  downloadCSV(csvRowsPark, `time-to-park`);\n});\n// When button with id \"export-goal\" is clicked, download the csv file with the data\ndocument.getElementById(\"export-goal\").addEventListener(\"click\", () => {\n  downloadCSV(csvRowsGoal, `time-to-goal`);\n});\n// Function to download the csv file\nfunction downloadCSV(csv, filename) {\n  var csvFile;\n  var downloadLink;\n\n  // CSV file\n  csvFile = new Blob([csv], { type: \"text/csv\" });\n  downloadLink = document.createElement(\"a\");\n  downloadLink.download =\n    filename + `===${selectedStrategies.join(\"-\")}===peak-${maxSpawnRate}.csv`;\n\n  // Add hidden download link\n  downloadLink.href = window.URL.createObjectURL(csvFile);\n  downloadLink.style.display = \"none\";\n  document.body.appendChild(downloadLink);\n  downloadLink.click();\n}\n"]}